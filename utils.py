import numpy as np
from config import *


# Calculates class intersections over unions
def iou(pred, gt):
    ious = []
    for cls in range(n_classes):
        pred_inds = pred == cls
        target_inds = gt == cls
        intersection = pred_inds[target_inds].sum()
        union = pred_inds.sum() + target_inds.sum() - intersection
        if union == 0:
            ious.append(float('nan'))  # if there is no ground truth, do not include in evaluation
        else:
            ious.append(float(intersection) / max(union, 1))
        # print("cls", cls, pred_inds.sum(), target_inds.sum(), intersection, float(intersection) / max(union, 1))
    return ious

def calc_iou(pred,gt,n_classes):
    mask = (gt >= 0) & (pred < n_classes)
    hist = np.bincount(n_classes * gt[mask].astype(int) + pred[mask], minlength=n_classes ** 2
                       ).reshape(n_classes, n_classes)

    iou = np.diag(hist) / (hist.sum(axis=1) + hist.sum(axis=0) - np.diag(hist))
    mean_iou = np.nanmean(iou)

    return mean_iou

def get_color_index():
    colors_index = [
        [128, 64, 128],
        [244, 35, 232],
        [70, 70, 70],
        [102, 102, 156],
        [190, 153, 153],
        [153, 153, 153],
        [250, 170, 30],
        [220, 220, 0],
        [107, 142, 35],
        [152, 251, 152],
        [0, 130, 180],
        [220, 20, 60],
        [255, 0, 0],
        [0, 0, 142],
        [0, 0, 70],
        [0, 60, 100],
        [0, 80, 100],
        [0, 0, 230],
        [119, 11, 32],
    ]
    return colors_index